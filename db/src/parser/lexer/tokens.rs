use super::LexError;

#[derive(Debug, PartialEq, Clone)]
pub struct PositionedToken<'a> {
    pub token: Token<'a>,
    pub start: usize,
    pub end: usize,
}

impl<'a> PositionedToken<'a> {
    pub fn from_str(
        word: &'a str,
        started_position: usize,
    ) -> Option<Result<PositionedToken<'a>, LexError>> {
        let token = Token::from_str(word).unwrap().unwrap(); // FIXME: unwrap
        let end_position = started_position + word.len();
        Some(Ok(PositionedToken {
            token,
            start: started_position,
            end: end_position,
        }))
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Token<'a> {
    Select,
    From,
    Where,
    Insert,
    Into,
    Values,
    Update,
    Set,
    Delete,
    Create,
    Table,
    Primary,
    Key,
    Foreign,
    References,
    Drop,
    Alter,
    Add,
    Column,
    Constraint,
    Index,
    Join,
    Inner,
    Left,
    Right,
    Full,
    Outer,
    On,
    Group,
    By,
    Order,
    Asc,
    Desc,
    Union,
    All,
    Distinct,
    Limit,
    Offset,
    Having,
    As,
    And,
    Or,
    Not,
    Null,
    Is,
    In,
    Between,
    Like,
    Exists,
    Any,
    Case,
    When,
    Then,
    Else,
    End,
    Default,

    Int,
    Integer,
    SmallInt,
    TinyInt,
    BigInt,
    Float,
    Real,
    Double,
    Decimal,
    Numeric,
    VarChar,
    Char,
    Text,
    Date,
    DateTime,
    Time,
    Timestamp,
    Boolean,

    Asterisk,
    Comma,
    Semicolon,
    OpenParen,
    CloseParen,
    Equals,
    NotEquals,
    LessThan,
    GreaterThan,
    LessThanOrEquals,
    GreaterThanOrEquals,
    Plus,
    Minus,
    Slash,
    Percent,
    Concat,
    SingleQuote,
    DoubleQuote,

    Identifier {
        first_name: &'a str,
        second_name: Option<&'a str>,
        third_name: Option<&'a str>,
    },

    StringLiteral(String),
    NumericLiteral(String),
    BooleanLiteral(bool),

    SingleLineComment(String),
    MultiLineComment(String),
}

impl<'a> Token<'a> {
    pub fn identifier(first_name: &'a str) -> Token<'a> {
        Token::Identifier {
            first_name,
            second_name: None,
            third_name: None,
        }
    }

    pub fn from_str(word: &'a str) -> Option<Result<Token<'a>, LexError>> {
        let binding = word.to_lowercase();
        let lower_case_word = binding.as_str();

        let t = match lower_case_word {
            "select" => Token::Select,
            "from" => Token::From,
            "where" => Token::Where,
            "insert" => Token::Insert,
            "into" => Token::Into,
            "values" => Token::Values,
            "update" => Token::Update,
            "set" => Token::Set,
            "delete" => Token::Delete,
            "create" => Token::Create,
            "table" => Token::Table,
            "primary" => Token::Primary,
            "key" => Token::Key,
            "foreign" => Token::Foreign,
            "references" => Token::References,
            "drop" => Token::Drop,
            "alter" => Token::Alter,
            "add" => Token::Add,
            "column" => Token::Column,
            "constraint" => Token::Constraint,
            "index" => Token::Index,
            "join" => Token::Join,
            "inner" => Token::Inner,
            "left" => Token::Left,
            "right" => Token::Right,
            "full" => Token::Full,
            "outer" => Token::Outer,
            "on" => Token::On,
            "group" => Token::Group,
            "by" => Token::By,
            "order" => Token::Order,
            "asc" => Token::Asc,
            "desc" => Token::Desc,
            "union" => Token::Union,
            "all" => Token::All,
            "distinct" => Token::Distinct,
            "limit" => Token::Limit,
            "offset" => Token::Offset,
            "having" => Token::Having,
            "as" => Token::As,
            "and" => Token::And,
            "or" => Token::Or,
            "not" => Token::Not,
            "null" => Token::Null,
            "is" => Token::Is,
            "in" => Token::In,
            "between" => Token::Between,
            "like" => Token::Like,
            "exists" => Token::Exists,
            "any" => Token::Any,
            "case" => Token::Case,
            "when" => Token::When,
            "then" => Token::Then,
            "else" => Token::Else,
            "end" => Token::End,
            "default" => Token::Default,
            "true" => Token::BooleanLiteral(true),
            "false" => Token::BooleanLiteral(false),
            "int" => Token::Int,
            "integer" => Token::Integer,
            "smallint" => Token::SmallInt,
            "tinyint" => Token::TinyInt,
            "bigint" => Token::BigInt,
            "float" => Token::Float,
            "real" => Token::Real,
            "double" => Token::Double,
            "decimal" => Token::Decimal,
            "numeric" => Token::Numeric,
            "varchar" => Token::VarChar,
            "char" => Token::Char,
            "text" => Token::Text,
            "date" => Token::Date,
            "time" => Token::Time,
            "timestamp" => Token::Timestamp,
            "datetime" => Token::DateTime,
            "boolean" => Token::Boolean,
            _ => Token::identifier(word),
        };

        Some(Ok(t))
    }
}
